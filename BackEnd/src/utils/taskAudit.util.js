const Comment = require('../model/Comment.model');
const TaskHistory = require('../model/TaskHistory.model');
const Task = require('../model/Task.model');

const ensureString = (value, fallback = 'system') => {
    if (value === null || value === undefined) {
        return fallback;
    }
    return String(value);
};

const normaliseEmail = (email) => (typeof email === 'string' ? email.trim().toLowerCase() : '');

const formatStatus = (status) => {
    if (!status) return 'Unknown';
    return status
        .toString()
        .replace(/_/g, ' ')
        .replace(/\b\w/g, (char) => char.toUpperCase());
};

const getActorInfo = (req = {}) => {
    const user = req.user || {};
    const body = req.body || {};
    const actorPayload = body.actor || {};

    const actorId = ensureString(
        user.id || user._id || user.userId || body.userId || actorPayload.id || actorPayload.userId,
        'system'
    );

    const actorName = user.name || body.userName || actorPayload.userName || 'System';
    const actorEmail = user.email || body.userEmail || actorPayload.userEmail || 'system@task-app.local';
    const actorRole = user.role || body.userRole || actorPayload.userRole || 'system';

    return {
        id: ensureString(actorId, 'system'),
        name: actorName,
        email: actorEmail,
        role: actorRole
    };
};

const getTaskEmail = (value) => {
    if (!value) return '';
    if (typeof value === 'string') return value;
    if (typeof value === 'object' && value.email) return value.email;
    return '';
};

const buildStatusDescription = ({ actor, oldStatus, newStatus, note, extraContext }) => {
    let description = `${actor.name} (${actor.role}) changed task status from "${formatStatus(oldStatus)}" to "${formatStatus(newStatus)}".`;

    if (extraContext) {
        description += ` ${extraContext}`;
    }

    if (note) {
        description += ` Note: ${note}`;
    }

    return description;
};

const buildStatusComment = ({ actor, oldStatus, newStatus, note, extraContext }) => {
    const parts = [
        `Status: ${formatStatus(oldStatus)} â†’ ${formatStatus(newStatus)}`,
        `By: ${actor.name}${actor.role ? ` (${actor.role})` : ''}`
    ];

    if (extraContext) {
        parts.push(extraContext);
    }

    if (note) {
        parts.push(`Note: ${note}`);
    }

    return parts.join(' | ');
};

const buildApprovalDescription = ({ actor, granted, note, isAdmin, isAssigner }) => {
    let description;

    if (isAdmin) {
        description = granted
            ? `Admin ${actor.name} approved the task completion.`
            : `Admin ${actor.name} rejected the task completion.`;
    } else if (isAssigner) {
        description = granted
            ? `Assigner ${actor.name} permanently approved the task.`
            : `Assigner ${actor.name} removed the permanent approval.`;
    } else {
        description = granted
            ? `${actor.name} granted completion approval.`
            : `${actor.name} revoked completion approval.`;
    }

    if (note) {
        description += ` Note: ${note}`;
    }

    return description;
};

const buildApprovalComment = ({ actor, granted, note, isAdmin, isAssigner }) => {
    const actionText = granted
        ? (isAdmin ? 'Admin approval granted' : isAssigner ? 'Permanent approval granted' : 'Approval granted')
        : (isAdmin ? 'Admin approval revoked' : isAssigner ? 'Permanent approval removed' : 'Approval revoked');

    const parts = [
        actionText,
        `By: ${actor.name}${actor.role ? ` (${actor.role})` : ''}`
    ];

    if (note) {
        parts.push(`Note: ${note}`);
    }

    return parts.join(' | ');
};

const createHistoryAndComment = async ({
    taskId,
    actor,
    action,
    description,
    oldStatus,
    newStatus,
    note,
    commentContent
}) => {
    const history = await TaskHistory.create({
        taskId,
        action,
        description,
        oldStatus: oldStatus || null,
        newStatus: newStatus || null,
        note: note || '',
        userId: actor.id,
        user: {
            userId: actor.id,
            userName: actor.name,
            userEmail: actor.email,
            userRole: actor.role
        }
    });

    const comment = await Comment.create({
        taskId,
        content: commentContent || description,
        userId: actor.id,
        userName: actor.name,
        userEmail: actor.email,
        userRole: actor.role,
        autoGenerated: true
    });

    await Task.findByIdAndUpdate(taskId, {
        $addToSet: {
            comments: comment._id,
            history: history._id
        },
        updatedAt: Date.now()
    });

    return { history, comment };
};

const recordStatusChange = async ({
    req,
    previousTask,
    updatedTask,
    note = '',
    actionHint,
    requestRecheck = false
}) => {
    if (!previousTask || !updatedTask) return null;

    const oldStatus = previousTask.status;
    const newStatus = updatedTask.status;

    if (!newStatus || oldStatus === newStatus) {
        return null;
    }

    const actor = getActorInfo(req);
    const actorEmail = normaliseEmail(actor.email);
    const assignedToEmail = normaliseEmail(getTaskEmail(previousTask.assignedTo));
    const assignedByEmail = normaliseEmail(getTaskEmail(previousTask.assignedBy));

    const isAdmin = actor.role === 'admin';
    const isAssigner = actorEmail && assignedByEmail && actorEmail === assignedByEmail;
    const isAssignee = actorEmail && assignedToEmail && actorEmail === assignedToEmail;

    let action = actionHint;
    let extraContext = '';

    if (!action) {
        if (requestRecheck && isAssigner) {
            action = 'assigner_recheck_requested';
            extraContext = 'Assigner requested a re-check.';
        } else if (newStatus === 'completed') {
            if (isAdmin) action = 'status_completed_by_admin';
            else if (isAssigner) action = 'status_completed_by_assigner';
            else action = 'status_completed_by_assignee';
        } else if (newStatus === 'pending') {
            if (isAdmin) action = 'status_pending_by_admin';
            else if (isAssigner) action = 'status_pending_by_assigner';
            else action = 'status_pending_by_assignee';
        } else {
            action = 'status_changed';
        }
    }

    if (!extraContext && requestRecheck && isAssigner) {
        extraContext = 'Assigner requested a re-check.';
    }

    const description = buildStatusDescription({
        actor,
        oldStatus,
        newStatus,
        note,
        extraContext
    });

    const commentContent = buildStatusComment({
        actor,
        oldStatus,
        newStatus,
        note,
        extraContext
    });

    return createHistoryAndComment({
        taskId: updatedTask._id,
        actor,
        action,
        description,
        oldStatus,
        newStatus,
        note,
        commentContent
    });
};

const recordApprovalChange = async ({
    req,
    previousTask,
    updatedTask,
    note = '',
    actionHint
}) => {
    if (!previousTask || !updatedTask) return null;

    const previousApproval = Boolean(previousTask.completedApproval);
    const nextApproval = Boolean(updatedTask.completedApproval);

    if (previousApproval === nextApproval) {
        return null;
    }

    const actor = getActorInfo(req);
    const actorEmail = normaliseEmail(actor.email);
    const assignedByEmail = normaliseEmail(getTaskEmail(previousTask.assignedBy));

    const isAdmin = actor.role === 'admin';
    const isAssigner = actorEmail && assignedByEmail && actorEmail === assignedByEmail;

    let action = actionHint;

    if (!action) {
        if (isAdmin) {
            action = nextApproval ? 'admin_approved' : 'admin_rejected';
        } else if (isAssigner) {
            action = nextApproval ? 'assigner_permanent_approved' : 'permanent_approval_removed';
        } else {
            action = nextApproval ? 'approval_granted' : 'approval_revoked';
        }
    }

    const description = buildApprovalDescription({
        actor,
        granted: nextApproval,
        note,
        isAdmin,
        isAssigner
    });

    const commentContent = buildApprovalComment({
        actor,
        granted: nextApproval,
        note,
        isAdmin,
        isAssigner
    });

    return createHistoryAndComment({
        taskId: updatedTask._id,
        actor,
        action,
        description,
        oldStatus: previousTask.status,
        newStatus: updatedTask.status,
        note,
        commentContent
    });
};

module.exports = {
    recordStatusChange,
    recordApprovalChange,
    formatStatus
};
